
-- supabase/migrations/0001_initial_schema.sql

-- 1. Create the user profiles table
-- This table stores public user data and is linked to the auth.users table.
CREATE TABLE public.sc_users (
    id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    email text NULL,
    full_name text NULL,
    credits integer NOT NULL DEFAULT 5,
    plan text NOT NULL DEFAULT 'Free'::text,
    referral_code uuid NOT NULL DEFAULT gen_random_uuid(),
    referred_by uuid NULL,
    created_at timestamp with time zone NULL DEFAULT now(),
    updated_at timestamp with time zone NULL DEFAULT now(),
    CONSTRAINT users_pkey PRIMARY KEY (id),
    CONSTRAINT users_email_key UNIQUE (email),
    CONSTRAINT users_referral_code_key UNIQUE (referral_code)
);

-- 2. Set up Row Level Security (RLS)
-- This ensures that users can only access their own data.
ALTER TABLE public.sc_users ENABLE ROW LEVEL SECURITY;

-- Policy: Users can see their own profile
CREATE POLICY "Users can see their own profile"
ON public.sc_users
FOR SELECT USING (auth.uid() = id);

-- Policy: Users can update their own profile
CREATE POLICY "Users can update their own profile"
ON public.sc_users
FOR UPDATE USING (auth.uid() = id);


-- 3. Create a trigger to automatically create a user profile on new user signup
-- This function will be called whenever a new user is created in the auth.users table.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  -- Insert a new row into public.sc_users
  INSERT INTO public.sc_users (id, email, full_name, referred_by)
  VALUES (
    new.id,
    new.email,
    new.raw_user_meta_data->>'full_name',
    (new.raw_user_meta_data->>'referral_code')::uuid
  );

  -- Award credit to the referrer, if one exists
  IF (new.raw_user_meta_data->>'referral_code') IS NOT NULL THEN
    UPDATE public.sc_users
    SET credits = credits + 10
    WHERE referral_code = (new.raw_user_meta_data->>'referral_code')::uuid;
  END IF;

  RETURN new;
END;
$$;

-- Create the trigger that calls the function
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- 4. Create database functions for managing credits and referrals

-- Function to decrement credits for a user
CREATE OR REPLACE FUNCTION public.decrement_credits(p_user_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  UPDATE public.sc_users
  SET credits = credits - 1
  WHERE id = p_user_id AND credits > 0;
END;
$$;

-- Function to award credit to a referrer
-- Note: The handle_new_user trigger already does this, but this function can be useful for manual adjustments or other referral scenarios.
CREATE OR REPLACE FUNCTION public.award_referral_credit(p_referrer_code uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  UPDATE public.sc_users
  SET credits = credits + 10
  WHERE referral_code = p_referrer_code;
END;
$$;


-- 5. Add a table for contact messages
CREATE TABLE public.contact_messages (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    full_name text not null,
    email text not null,
    message text not null,
    CONSTRAINT contact_messages_pkey PRIMARY KEY (id)
) tablespace pg_default;

-- Enable RLS for contact messages and allow inserts (e.g., from a web form)
ALTER TABLE public.contact_messages ENABLE ROW LEVEL SECURITY;
-- No policies for select/update/delete from anon/authenticated roles, only service_role can access.
-- This table is write-only for users.
CREATE POLICY "Allow public insert for contact messages"
ON public.contact_messages
FOR INSERT
WITH CHECK (true);
